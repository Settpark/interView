# Singleton

## Singleton의 정의

- 어떤 클래스를 어플리케이션 내에서 하나의 인스턴스가 존재하도록 강제하는 패턴
- 이렇게 하나만 만들어지는 클래스 오브젝트는 전역적으로 접근이 가능

## 사용시 주의해야할 점

- 상태를 가진 객체를 Singleton으로 만들면 안된다.
- 멀티 스레드 환경에서 어플리케이션에 단 한개의 인스턴스가 존재하고, 이를 전역에서 접근할 수 있다면 각기 다른 스레드에서 마구잡이로 변경시킬 여지가 있다.
- 무 상태 객체나 설계상 유일해야 하는 시스템 컴포넌트를 Singleton으로 만들어야 한다.

### Singleton의 사용법

1. 클래스 밖에서 오브젝트 생성을 제한하기 위하여 기본 생성자를 `private`로 만든다.
2. 생성된 Singleton Object를 저장할 수 있는 자신과 같은 static 필드를 정의한다.
3. static 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 생성 된 오브젝트는 static 필드에 저장된다. 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
4. 한번 만들어지고 난 후에는 이미 만들어져 스태틱 필드에 저장된 오브젝트를 넘겨준다.

## Singleton이 안티패턴이라 불리는 이유

1. SOLID 원칙의 대부분은 인터페이스 설계와 관련이 있다. 
2. 싱글톤을 사용하는 경우 대부분 인터페이스가 아닌 콘크리트 클래스의 객체를 미리 생성해놓고 정적 메소드를 이용하여 사용하게 된다. 따라서, 싱글톤 클래스와 싱글톤을 사용하는 클래스 사이에서 강한 의존성을 나타내게 된다. 
3. 이러한 높은 결합은 수정, 단위테스트에 어려움 등 다양한 문제가 발생한다.

### 객체지향과 맞지 않다.

- 싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다. **아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 지양되어야 할 모델**이다. 또한 싱글톤은 private 생성자를 갖고 있기 때문에 상속할 수 없다. static 필드와 메소드를 사용하기 때문에 다형성 같은 객체지향 특징이 적용되지 않는다.

### 테스트하기 어렵다.

- 높은 결합 때문에 단위 테스트가 어렵다.
- 이펙티브 자바 아이템3
    
    > *클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜 구현(mock object)으로 대체할 수 없기 때문이다.*
    > 
    

## 싱글톤 패턴 사용법

1. 클래스 밖에서는 오브젝트를 생성하지 못하도록  **기본 생성자를 private** 으로 만든다.
2. 생성된 Singleton Object를 저장할 수 있는  **자신과 같은 타입의 static 필드** 를 정의한다.
3. **static 팩토리 메소드인 getInstance()** 를 만들고 이 메소드가 **최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게** 한다. 생성된 오브젝트는 static 필드에 저장된다. 또는 스태틱 필드의 **초기값으로 오브젝트를 미리 만들어둘 수도 있다**.
4. 한 번 오브젝트가 만들어지고 난 후에는 getInstance() 메소드를 통해 **이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.**
- 아래는 예시 코드:

```swift
class Singleton {    
    static private var shared: Singleton? = nil
    
    private init() { }
    
    static public func getInstance() -> Singleton? {
        if self.shared == nil {
            self.shared = Singleton()
        }
        return self.shared
    }
}
```