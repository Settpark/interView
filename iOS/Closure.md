## 재정리 이유

- bind { }, flatMap { }, map { } 등에서 발생하는 캡처리스트 이슈의 이해를 더욱 높이기 위함

## 클로저란?

- 일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것을 클로저라 함. 타 언어의 람다와 비슷합니다.
- 클로저는 변수가 선언된 위치에서 참조하고 획득할 수 있습니다.

### 클로저의 형태

- 이름이 있으면서 어떠한 값도 획득하지 않은 전역함수의 형태
- 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
- 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

### 클로저의 표현

- 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 반환 값의 타입을 생략할 수 있습니다.
- 단 한줄의 표현만 있다면 이를 반환 값으로 취급합니다.
- 축약된 전달인자 이름을 사용할 수 있습니다.
- 후행 클로저 문법을 사용할 수 있습니다.

### 값 획득

- 주변 문맥을 통해 값을 획득 (Capture) 할 수 있습니다.
- 클로저는 비동기 작업에 많이 사용됩니다. 클로저를 통해 비동기 콜백을 작성하는 경우, 현재 상태를 미리 획득 해두지 않으면, 실제로 클로저의 기능을 실행하는 순간에는 주변의 상수나 변수가 이미 메모리에 존재하지 않는 경우가 발생합니다.

### 클로저는 참조 타입

- 함수와 클로저는 참조 타입입니다.
- 아래의 예제 코드에서 `incrementByTwo = makeIncrementer(forIncrement: 2)`는 참조를 할당한 것
- 상수나 변수에 클로저를 할당할 때마다 사실은 상수나 변수에 클로저의 참조를 설정하는 것입니다.
    
    ```swift
    func makeIncrementer(forIncrement amount: Int) -> (() -> Int) {
        var runningTotal = 0
        func incrementer() -> Int {
            runningTotal += amount
            return runningTotal
        }
        return incrementer
    }
    let incrementByTwo: (() -> Int) = makeIncrementer(forIncrement: 2)
    ```